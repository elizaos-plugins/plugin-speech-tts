{"version":3,"sources":["../src/services/speech.ts","../src/services/audioUtils.ts","../src/environment.ts","../src/services/transcription.ts","../src/actions/describe-image.ts","../src/templates.ts","../src/types.ts","../src/index.ts"],"sourcesContent":["import { PassThrough } from \"stream\";\nimport { Readable } from \"node:stream\";\nimport { ReadableStream } from \"node:stream/web\";\nimport { IAgentRuntime, ISpeechService, ServiceType } from \"@elizaos/core\";\nimport { getWavHeader } from \"./audioUtils.js\";\nimport { Service } from \"@elizaos/core\";\nimport { validateNodeConfig } from \"../environment.js\";\nimport * as Echogarden from \"echogarden\";\nimport { elizaLogger } from \"@elizaos/core\";\n\nfunction prependWavHeader(\n    readable: Readable,\n    audioLength: number,\n    sampleRate: number,\n    channelCount: number = 1,\n    bitsPerSample: number = 16\n): Readable {\n    const wavHeader = getWavHeader(\n        audioLength,\n        sampleRate,\n        channelCount,\n        bitsPerSample\n    );\n    let pushedHeader = false;\n    const passThrough = new PassThrough();\n    readable.on(\"data\", function (data) {\n        if (!pushedHeader) {\n            passThrough.push(wavHeader);\n            pushedHeader = true;\n        }\n        passThrough.push(data);\n    });\n    readable.on(\"end\", function () {\n        passThrough.end();\n    });\n    return passThrough;\n}\n\nasync function getVoiceSettings(runtime: IAgentRuntime) {\n    const hasElevenLabs = !!runtime.getSetting(\"ELEVENLABS_XI_API_KEY\");\n    const useVits = !hasElevenLabs;\n\n    // Get voice settings from character card\n    const voiceSettings = runtime.character.settings?.voice;\n    const elevenlabsSettings = voiceSettings?.elevenlabs;\n\n    elizaLogger.debug(\"Voice settings:\", {\n        hasElevenLabs,\n        useVits,\n        voiceSettings,\n        elevenlabsSettings,\n    });\n\n    return {\n        elevenlabsVoiceId:\n            elevenlabsSettings?.voiceId ||\n            runtime.getSetting(\"ELEVENLABS_VOICE_ID\"),\n        elevenlabsModel:\n            elevenlabsSettings?.model ||\n            runtime.getSetting(\"ELEVENLABS_MODEL_ID\") ||\n            \"eleven_monolingual_v1\",\n        elevenlabsStability:\n            elevenlabsSettings?.stability ||\n            runtime.getSetting(\"ELEVENLABS_VOICE_STABILITY\") ||\n            \"0.5\",\n        // ... other ElevenLabs settings ...\n        vitsVoice:\n            voiceSettings?.model ||\n            voiceSettings?.url ||\n            runtime.getSetting(\"VITS_VOICE\") ||\n            \"en_US-hfc_female-medium\",\n        elevenlabsUrl: runtime.getSetting(\"ELEVENLABS_XI_API_URL\") || \"https://api.elevenlabs.io/v1\",\n        useVits,\n    };\n}\n\nasync function textToSpeech(runtime: IAgentRuntime, text: string) {\n    await validateNodeConfig(runtime);\n    const { elevenlabsVoiceId, elevenlabsUrl } = await getVoiceSettings(runtime);\n\n    try {\n        const response = await fetch(\n            `${elevenlabsUrl}/text-to-speech/${elevenlabsVoiceId}/stream?optimize_streaming_latency=${runtime.getSetting(\"ELEVENLABS_OPTIMIZE_STREAMING_LATENCY\")}&output_format=${runtime.getSetting(\"ELEVENLABS_OUTPUT_FORMAT\")}`,\n            {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    \"xi-api-key\": runtime.getSetting(\"ELEVENLABS_XI_API_KEY\"),\n                },\n                body: JSON.stringify({\n                    model_id: runtime.getSetting(\"ELEVENLABS_MODEL_ID\"),\n                    text: text,\n                    voice_settings: {\n                        similarity_boost: runtime.getSetting(\n                            \"ELEVENLABS_VOICE_SIMILARITY_BOOST\"\n                        ),\n                        stability: runtime.getSetting(\n                            \"ELEVENLABS_VOICE_STABILITY\"\n                        ),\n                        style: runtime.getSetting(\"ELEVENLABS_VOICE_STYLE\"),\n                        use_speaker_boost: runtime.getSetting(\n                            \"ELEVENLABS_VOICE_USE_SPEAKER_BOOST\"\n                        ),\n                    },\n                }),\n            }\n        );\n\n        const status = response.status;\n        if (status != 200) {\n            const errorBodyString = await response.text();\n            const errorBody = JSON.parse(errorBodyString);\n\n            // Check for quota exceeded error\n            if (\n                status === 401 &&\n                errorBody.detail?.status === \"quota_exceeded\"\n            ) {\n                elizaLogger.log(\n                    \"ElevenLabs quota exceeded, falling back to VITS\"\n                );\n                throw new Error(\"QUOTA_EXCEEDED\");\n            }\n\n            throw new Error(\n                `Received status ${status} from Eleven Labs API: ${errorBodyString}`\n            );\n        }\n\n        if (response) {\n            const webStream = ReadableStream.from(\n                response.body as ReadableStream\n            );\n            const reader = webStream.getReader();\n\n            const readable = new Readable({\n                read() {\n                    reader.read().then(({ done, value }) => {\n                        if (done) {\n                            this.push(null);\n                        } else {\n                            this.push(value);\n                        }\n                    });\n                },\n            });\n\n            if (\n                runtime\n                    .getSetting(\"ELEVENLABS_OUTPUT_FORMAT\")\n                    .startsWith(\"pcm_\")\n            ) {\n                const sampleRate = parseInt(\n                    runtime.getSetting(\"ELEVENLABS_OUTPUT_FORMAT\").substring(4)\n                );\n                const withHeader = prependWavHeader(\n                    readable,\n                    1024 * 1024 * 100,\n                    sampleRate,\n                    1,\n                    16\n                );\n                return withHeader;\n            } else {\n                return readable;\n            }\n        } else {\n            return new Readable({\n                read() {},\n            });\n        }\n    } catch (error) {\n        if (error.message === \"QUOTA_EXCEEDED\") {\n            // Fall back to VITS\n            const { vitsVoice } = await getVoiceSettings(runtime);\n            const { audio } = await Echogarden.synthesize(text, {\n                engine: \"vits\",\n                voice: vitsVoice,\n            });\n\n            let wavStream: Readable;\n            if (audio instanceof Buffer) {\n                elizaLogger.log(\"audio is a buffer\");\n                wavStream = Readable.from(audio);\n            } else if (\"audioChannels\" in audio && \"sampleRate\" in audio) {\n                elizaLogger.log(\"audio is a RawAudio\");\n                const floatBuffer = Buffer.from(audio.audioChannels[0].buffer);\n                elizaLogger.log(\"buffer length: \", floatBuffer.length);\n\n                // Get the sample rate from the RawAudio object\n                const sampleRate = audio.sampleRate;\n\n                // Create a Float32Array view of the floatBuffer\n                const floatArray = new Float32Array(floatBuffer.buffer);\n\n                // Convert 32-bit float audio to 16-bit PCM\n                const pcmBuffer = new Int16Array(floatArray.length);\n                for (let i = 0; i < floatArray.length; i++) {\n                    pcmBuffer[i] = Math.round(floatArray[i] * 32767);\n                }\n\n                // Prepend WAV header to the buffer\n                const wavHeaderBuffer = getWavHeader(\n                    pcmBuffer.length * 2,\n                    sampleRate,\n                    1,\n                    16\n                );\n                const wavBuffer = Buffer.concat([\n                    wavHeaderBuffer,\n                    Buffer.from(pcmBuffer.buffer),\n                ]);\n\n                wavStream = Readable.from(wavBuffer);\n            } else {\n                throw new Error(\"Unsupported audio format\");\n            }\n            return wavStream;\n        }\n        throw error; // Re-throw other errors\n    }\n}\n\nasync function processVitsAudio(audio: any): Promise<Readable> {\n    let wavStream: Readable;\n    if (audio instanceof Buffer) {\n        elizaLogger.log(\"audio is a buffer\");\n        wavStream = Readable.from(audio);\n    } else if (\"audioChannels\" in audio && \"sampleRate\" in audio) {\n        elizaLogger.log(\"audio is a RawAudio\");\n        const floatBuffer = Buffer.from(audio.audioChannels[0].buffer);\n        elizaLogger.log(\"buffer length: \", floatBuffer.length);\n\n        const sampleRate = audio.sampleRate;\n        const floatArray = new Float32Array(floatBuffer.buffer);\n        const pcmBuffer = new Int16Array(floatArray.length);\n\n        for (let i = 0; i < floatArray.length; i++) {\n            pcmBuffer[i] = Math.round(floatArray[i] * 32767);\n        }\n\n        const wavHeaderBuffer = getWavHeader(\n            pcmBuffer.length * 2,\n            sampleRate,\n            1,\n            16\n        );\n        const wavBuffer = Buffer.concat([\n            wavHeaderBuffer,\n            Buffer.from(pcmBuffer.buffer),\n        ]);\n        wavStream = Readable.from(wavBuffer);\n    } else {\n        throw new Error(\"Unsupported audio format\");\n    }\n    return wavStream;\n}\n\nasync function generateVitsAudio(\n    runtime: IAgentRuntime,\n    text: string\n): Promise<Readable> {\n    const { vitsVoice } = await getVoiceSettings(runtime);\n    const { audio } = await Echogarden.synthesize(text, {\n        engine: \"vits\",\n        voice: vitsVoice,\n    });\n    return processVitsAudio(audio);\n}\n\nexport class SpeechService extends Service implements ISpeechService {\n    static serviceType: ServiceType = ServiceType.SPEECH_GENERATION;\n\n    async initialize(_runtime: IAgentRuntime): Promise<void> {}\n\n    getInstance(): ISpeechService {\n        return SpeechService.getInstance();\n    }\n\n    async generate(runtime: IAgentRuntime, text: string): Promise<Readable> {\n        try {\n            const { useVits } = await getVoiceSettings(runtime);\n\n            if (useVits || !runtime.getSetting(\"ELEVENLABS_XI_API_KEY\")) {\n                return await generateVitsAudio(runtime, text);\n            }\n\n            return await textToSpeech(runtime, text);\n        } catch (error) {\n            console.error(\"Speech generation error:\", error);\n            return await generateVitsAudio(runtime, text);\n        }\n    }\n}\n","export function getWavHeader(\n    audioLength: number,\n    sampleRate: number,\n    channelCount: number = 1,\n    bitsPerSample: number = 16\n): Buffer {\n    const wavHeader = Buffer.alloc(44);\n    wavHeader.write(\"RIFF\", 0);\n    wavHeader.writeUInt32LE(36 + audioLength, 4); // Length of entire file in bytes minus 8\n    wavHeader.write(\"WAVE\", 8);\n    wavHeader.write(\"fmt \", 12);\n    wavHeader.writeUInt32LE(16, 16); // Length of format data\n    wavHeader.writeUInt16LE(1, 20); // Type of format (1 is PCM)\n    wavHeader.writeUInt16LE(channelCount, 22); // Number of channels\n    wavHeader.writeUInt32LE(sampleRate, 24); // Sample rate\n    wavHeader.writeUInt32LE(\n        (sampleRate * bitsPerSample * channelCount) / 8,\n        28\n    ); // Byte rate\n    wavHeader.writeUInt16LE((bitsPerSample * channelCount) / 8, 32); // Block align ((BitsPerSample * Channels) / 8)\n    wavHeader.writeUInt16LE(bitsPerSample, 34); // Bits per sample\n    wavHeader.write(\"data\", 36); // Data chunk header\n    wavHeader.writeUInt32LE(audioLength, 40); // Data chunk size\n    return wavHeader;\n}\n","import { IAgentRuntime } from \"@elizaos/core\";\nimport { z } from \"zod\";\n\nexport const nodeEnvSchema = z.object({\n    OPENAI_API_KEY: z.string().min(1, \"OpenAI API key is required\"),\n\n    // Core settings\n    ELEVENLABS_XI_API_KEY: z.string().optional(),\n\n    // All other settings optional with defaults\n    ELEVENLABS_MODEL_ID: z.string().optional(),\n    ELEVENLABS_VOICE_ID: z.string().optional(),\n    ELEVENLABS_VOICE_STABILITY: z.string().optional(),\n    ELEVENLABS_VOICE_SIMILARITY_BOOST: z.string().optional(),\n    ELEVENLABS_VOICE_STYLE: z.string().optional(),\n    ELEVENLABS_VOICE_USE_SPEAKER_BOOST: z.string().optional(),\n    ELEVENLABS_OPTIMIZE_STREAMING_LATENCY: z.string().optional(),\n    ELEVENLABS_OUTPUT_FORMAT: z.string().optional(),\n    VITS_VOICE: z.string().optional(),\n    VITS_MODEL: z.string().optional(),\n});\n\nexport type NodeConfig = z.infer<typeof nodeEnvSchema>;\n\nexport async function validateNodeConfig(\n    runtime: IAgentRuntime\n): Promise<NodeConfig> {\n    try {\n        const voiceSettings = runtime.character.settings?.voice;\n        const elevenlabs = voiceSettings?.elevenlabs;\n\n        // Only include what's absolutely required\n        const config = {\n            OPENAI_API_KEY:\n                runtime.getSetting(\"OPENAI_API_KEY\") ||\n                process.env.OPENAI_API_KEY,\n            ELEVENLABS_XI_API_KEY:\n                runtime.getSetting(\"ELEVENLABS_XI_API_KEY\") ||\n                process.env.ELEVENLABS_XI_API_KEY,\n\n            // Use character card settings first, fall back to env vars, then defaults\n            ...(runtime.getSetting(\"ELEVENLABS_XI_API_KEY\") && {\n                ELEVENLABS_MODEL_ID:\n                    elevenlabs?.model ||\n                    process.env.ELEVENLABS_MODEL_ID ||\n                    \"eleven_monolingual_v1\",\n                ELEVENLABS_VOICE_ID:\n                    elevenlabs?.voiceId || process.env.ELEVENLABS_VOICE_ID,\n                ELEVENLABS_VOICE_STABILITY:\n                    elevenlabs?.stability ||\n                    process.env.ELEVENLABS_VOICE_STABILITY ||\n                    \"0.5\",\n                ELEVENLABS_VOICE_SIMILARITY_BOOST:\n                    elevenlabs?.similarityBoost ||\n                    process.env.ELEVENLABS_VOICE_SIMILARITY_BOOST ||\n                    \"0.75\",\n                ELEVENLABS_VOICE_STYLE:\n                    elevenlabs?.style ||\n                    process.env.ELEVENLABS_VOICE_STYLE ||\n                    \"0\",\n                ELEVENLABS_VOICE_USE_SPEAKER_BOOST:\n                    elevenlabs?.useSpeakerBoost ||\n                    process.env.ELEVENLABS_VOICE_USE_SPEAKER_BOOST ||\n                    \"true\",\n                ELEVENLABS_OPTIMIZE_STREAMING_LATENCY:\n                    process.env.ELEVENLABS_OPTIMIZE_STREAMING_LATENCY || \"0\",\n                ELEVENLABS_OUTPUT_FORMAT:\n                    process.env.ELEVENLABS_OUTPUT_FORMAT || \"pcm_16000\",\n            }),\n\n            // VITS settings\n            VITS_VOICE: voiceSettings?.model || process.env.VITS_VOICE,\n            VITS_MODEL: process.env.VITS_MODEL,\n\n            // AWS settings (only include if presen\n        };\n\n        return nodeEnvSchema.parse(config);\n    } catch (error) {\n        if (error instanceof z.ZodError) {\n            const errorMessages = error.errors\n                .map((err) => `${err.path.join(\".\")}: ${err.message}`)\n                .join(\"\\n\");\n            throw new Error(\n                `Node configuration validation failed:\\n${errorMessages}`\n            );\n        }\n        throw error;\n    }\n}\n","import {\n    elizaLogger,\n    IAgentRuntime,\n    ITranscriptionService,\n    settings,\n    TranscriptionProvider,\n} from \"@elizaos/core\";\nimport { Service, ServiceType } from \"@elizaos/core\";\nimport { exec } from \"child_process\";\nimport { File } from \"formdata-node\";\nimport fs from \"fs\";\nimport { nodewhisper } from \"nodejs-whisper\";\nimport OpenAI from \"openai\"; // todo, can probably move this to model provider or whateer\nimport os from \"os\";\nimport path from \"path\";\nimport { fileURLToPath } from \"url\";\nimport { promisify } from \"util\";\nimport { createClient, DeepgramClient } from \"@deepgram/sdk\";\n\n// const __dirname = path.dirname(new URL(import.meta.url).pathname); #compatibility issues with windows\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\nconst execAsync = promisify(exec);\n\nexport class TranscriptionService\n    extends Service\n    implements ITranscriptionService\n{\n    private runtime: IAgentRuntime | null = null;\n    static serviceType: ServiceType = ServiceType.TRANSCRIPTION;\n    private CONTENT_CACHE_DIR: string;\n    private DEBUG_AUDIO_DIR: string;\n    private TARGET_SAMPLE_RATE = 16000; // Common sample rate for speech recognition\n    private isCudaAvailable: boolean = false;\n\n    /**\n     * CHANGED: We now use TranscriptionProvider instead of separate flags/strings.\n     * This allows us to handle character settings, env variables, and fallback logic.\n     */\n    private transcriptionProvider: TranscriptionProvider | null = null;\n\n    private deepgram: DeepgramClient | null = null;\n    private openai: OpenAI | null = null;\n\n    /**\n     * We keep the queue and processing logic as is.\n     */\n    private queue: { audioBuffer: ArrayBuffer; resolve: Function }[] = [];\n    private processing: boolean = false;\n\n    /**\n     * CHANGED: initialize() now checks:\n     * 1) character.settings.transcription (if available and keys exist),\n     * 2) then the .env TRANSCRIPTION_PROVIDER,\n     * 3) then old fallback logic (Deepgram -> OpenAI -> local).\n     */\n    async initialize(_runtime: IAgentRuntime): Promise<void> {\n        this.runtime = _runtime;\n\n        const openaiBaseURL = this.runtime.getSetting(\n            \"OPENAI_API_URL\"\n        )\n\n        elizaLogger.log(\"OPENAI_API_URL\", openaiBaseURL)\n\n        // 1) Check character settings\n        let chosenProvider: TranscriptionProvider | null = null;\n        const charSetting = this.runtime.character?.settings?.transcription;\n\n        if (charSetting === TranscriptionProvider.Deepgram) {\n            const deepgramKey = this.runtime.getSetting(\"DEEPGRAM_API_KEY\");\n            if (deepgramKey) {\n                this.deepgram = createClient(deepgramKey);\n                chosenProvider = TranscriptionProvider.Deepgram;\n            }\n        } else if (charSetting === TranscriptionProvider.OpenAI) {\n            const openaiKey = this.runtime.getSetting(\"OPENAI_API_KEY\");\n            if (openaiKey) {\n                this.openai = new OpenAI({ apiKey: openaiKey, baseURL: openaiBaseURL });\n                chosenProvider = TranscriptionProvider.OpenAI;\n            }\n        } else if (charSetting === TranscriptionProvider.Local) {\n            chosenProvider = TranscriptionProvider.Local;\n        }\n\n        // 2) If not chosen from character, check .env\n        if (!chosenProvider) {\n            const envProvider = this.runtime.getSetting(\n                \"TRANSCRIPTION_PROVIDER\"\n            );\n            if (envProvider) {\n                switch (envProvider.toLowerCase()) {\n                    case \"deepgram\":\n                        {\n                            const dgKey =\n                                this.runtime.getSetting(\"DEEPGRAM_API_KEY\");\n                            if (dgKey) {\n                                this.deepgram = createClient(dgKey);\n                                chosenProvider = TranscriptionProvider.Deepgram;\n                            }\n                        }\n                        break;\n                    case \"openai\":\n                        {\n                            const openaiKey =\n                                this.runtime.getSetting(\"OPENAI_API_KEY\");\n                            if (openaiKey) {\n                                this.openai = new OpenAI({ apiKey: openaiKey, baseURL: openaiBaseURL});\n                                chosenProvider = TranscriptionProvider.OpenAI;\n                            }\n                        }\n                        break;\n                    case \"local\":\n                        chosenProvider = TranscriptionProvider.Local;\n                        break;\n                }\n            }\n        }\n\n        // 3) If still none, fallback to old logic: Deepgram -> OpenAI -> local\n        if (!chosenProvider) {\n            const deepgramKey = this.runtime.getSetting(\"DEEPGRAM_API_KEY\");\n            if (deepgramKey) {\n                this.deepgram = createClient(deepgramKey);\n                chosenProvider = TranscriptionProvider.Deepgram;\n            } else {\n                const openaiKey = this.runtime.getSetting(\"OPENAI_API_KEY\");\n                if (openaiKey) {\n                    this.openai = new OpenAI({ apiKey: openaiKey, baseURL: openaiBaseURL });\n                    chosenProvider = TranscriptionProvider.OpenAI;\n                } else {\n                    chosenProvider = TranscriptionProvider.Local;\n                }\n            }\n        }\n\n        this.transcriptionProvider = chosenProvider;\n\n        // Leave detectCuda as is.\n        this.detectCuda();\n    }\n\n    constructor() {\n        super();\n        const rootDir = path.resolve(__dirname, \"../../\");\n        this.CONTENT_CACHE_DIR = path.join(rootDir, \"content_cache\");\n        this.DEBUG_AUDIO_DIR = path.join(rootDir, \"debug_audio\");\n        this.ensureCacheDirectoryExists();\n        this.ensureDebugDirectoryExists();\n        // TODO: It'd be nice to handle this more gracefully, but we can do local transcription for now\n        // TODO: remove the runtime from here, use it when called\n        // if (runtime.getSetting(\"OPENAI_API_KEY\")) {\n        //     this.openai = new OpenAI({\n        //         apiKey: runtime.getSetting(\"OPENAI_API_KEY\"),\n        //     });\n        // } else {\n        //     this.detectCuda();\n        // }\n    }\n\n    private ensureCacheDirectoryExists() {\n        if (!fs.existsSync(this.CONTENT_CACHE_DIR)) {\n            fs.mkdirSync(this.CONTENT_CACHE_DIR, { recursive: true });\n        }\n    }\n\n    private ensureDebugDirectoryExists() {\n        if (!fs.existsSync(this.DEBUG_AUDIO_DIR)) {\n            fs.mkdirSync(this.DEBUG_AUDIO_DIR, { recursive: true });\n        }\n    }\n\n    private detectCuda() {\n        const platform = os.platform();\n        if (platform === \"linux\") {\n            try {\n                fs.accessSync(\"/usr/local/cuda/bin/nvcc\", fs.constants.X_OK);\n                this.isCudaAvailable = true;\n                elizaLogger.log(\n                    \"CUDA detected. Transcription will use CUDA acceleration.\"\n                );\n                // eslint-disable-next-line\n            } catch (_error) {\n                elizaLogger.log(\n                    \"CUDA not detected. Transcription will run on CPU.\"\n                );\n            }\n        } else if (platform === \"win32\") {\n            const cudaPath = path.join(\n                settings.CUDA_PATH ||\n                    \"C:\\\\Program Files\\\\NVIDIA GPU Computing Toolkit\\\\CUDA\\\\v11.0\",\n                \"bin\",\n                \"nvcc.exe\"\n            );\n            if (fs.existsSync(cudaPath)) {\n                this.isCudaAvailable = true;\n                elizaLogger.log(\n                    \"CUDA detected. Transcription will use CUDA acceleration.\"\n                );\n            } else {\n                elizaLogger.log(\n                    \"CUDA not detected. Transcription will run on CPU.\"\n                );\n            }\n        } else {\n            elizaLogger.log(\n                \"CUDA not supported on this platform. Transcription will run on CPU.\"\n            );\n        }\n    }\n\n    private async convertAudio(inputBuffer: ArrayBuffer): Promise<Buffer> {\n        const inputPath = path.join(\n            this.CONTENT_CACHE_DIR,\n            `input_${Date.now()}.wav`\n        );\n        const outputPath = path.join(\n            this.CONTENT_CACHE_DIR,\n            `output_${Date.now()}.wav`\n        );\n\n        fs.writeFileSync(inputPath, Buffer.from(inputBuffer));\n\n        try {\n            const { stdout } = await execAsync(\n                `ffprobe -v error -show_entries stream=codec_name,sample_rate,channels -of json \"${inputPath}\"`\n            );\n            const probeResult = JSON.parse(stdout);\n            const stream = probeResult.streams[0];\n\n            elizaLogger.log(\"Input audio info:\", stream);\n\n            let ffmpegCommand = `ffmpeg -i \"${inputPath}\" -ar ${this.TARGET_SAMPLE_RATE} -ac 1`;\n\n            if (stream.codec_name === \"pcm_f32le\") {\n                ffmpegCommand += \" -acodec pcm_s16le\";\n            }\n\n            ffmpegCommand += ` \"${outputPath}\"`;\n\n            elizaLogger.log(\"FFmpeg command:\", ffmpegCommand);\n\n            await execAsync(ffmpegCommand);\n\n            const convertedBuffer = fs.readFileSync(outputPath);\n            fs.unlinkSync(inputPath);\n            fs.unlinkSync(outputPath);\n            return convertedBuffer;\n        } catch (error) {\n            elizaLogger.error(\"Error converting audio:\", error);\n            throw error;\n        }\n    }\n\n    private async saveDebugAudio(audioBuffer: ArrayBuffer, prefix: string) {\n        this.ensureDebugDirectoryExists();\n\n        const filename = `${prefix}_${Date.now()}.wav`;\n        const filePath = path.join(this.DEBUG_AUDIO_DIR, filename);\n\n        fs.writeFileSync(filePath, Buffer.from(audioBuffer));\n        elizaLogger.log(`Debug audio saved: ${filePath}`);\n    }\n\n    public async transcribeAttachment(\n        audioBuffer: ArrayBuffer\n    ): Promise<string | null> {\n        return await this.transcribe(audioBuffer);\n    }\n\n    /**\n     * If the audio buffer is too short, return null. Otherwise push to queue.\n     */\n    public async transcribe(audioBuffer: ArrayBuffer): Promise<string | null> {\n        // if the audio buffer is less than .2 seconds, just return null\n        if (audioBuffer.byteLength < 0.2 * 16000) {\n            return null;\n        }\n        return new Promise((resolve) => {\n            this.queue.push({ audioBuffer, resolve });\n            if (!this.processing) {\n                this.processQueue();\n            }\n        });\n    }\n\n    public async transcribeAttachmentLocally(\n        audioBuffer: ArrayBuffer\n    ): Promise<string | null> {\n        return this.transcribeLocally(audioBuffer);\n    }\n\n    /**\n     * CHANGED: processQueue() uses the final transcriptionProvider enum set in initialize().\n     */\n    private async processQueue(): Promise<void> {\n        // Exit if already processing or if the queue is empty\n        if (this.processing || this.queue.length === 0) return;\n        this.processing = true;\n\n        while (this.queue.length > 0) {\n            const { audioBuffer, resolve } = this.queue.shift()!;\n            let result: string | null = null;\n\n            switch (this.transcriptionProvider) {\n                case TranscriptionProvider.Deepgram:\n                    result = await this.transcribeWithDeepgram(audioBuffer);\n                    break;\n                case TranscriptionProvider.OpenAI:\n                    result = await this.transcribeWithOpenAI(audioBuffer);\n                    break;\n                default:\n                    result = await this.transcribeLocally(audioBuffer);\n            }\n\n            resolve(result);\n        }\n\n        this.processing = false;\n    }\n\n    /**\n     * Original logic from main is now handled by the final fallback in initialize().\n     * We'll keep transcribeUsingDefaultLogic() if needed by other code references,\n     * but it's no longer invoked in the new flow.\n     */\n    private async transcribeUsingDefaultLogic(\n        audioBuffer: ArrayBuffer\n    ): Promise<string | null> {\n        if (this.deepgram) {\n            return await this.transcribeWithDeepgram(audioBuffer);\n        } else if (this.openai) {\n            return await this.transcribeWithOpenAI(audioBuffer);\n        }\n        return await this.transcribeLocally(audioBuffer);\n    }\n\n    private async transcribeWithDeepgram(\n        audioBuffer: ArrayBuffer\n    ): Promise<string | null> {\n        const buffer = Buffer.from(audioBuffer);\n        const response = await this.deepgram.listen.prerecorded.transcribeFile(\n            buffer,\n            {\n                model: \"nova-2\",\n                language: \"en-US\",\n                smart_format: true,\n            }\n        );\n        const result =\n            response.result.results.channels[0].alternatives[0].transcript;\n        return result;\n    }\n\n    private async transcribeWithOpenAI(\n        audioBuffer: ArrayBuffer\n    ): Promise<string | null> {\n        elizaLogger.log(\"Transcribing audio with OpenAI...\");\n\n        try {\n            await this.saveDebugAudio(audioBuffer, \"openai_input_original\");\n\n            const arrayBuffer = new Uint8Array(audioBuffer).buffer;\n            const convertedBuffer = Buffer.from(await this.convertAudio(arrayBuffer)).buffer;\n\n            await this.saveDebugAudio(\n                convertedBuffer,\n                \"openai_input_converted\"\n            );\n\n            const file = new File([convertedBuffer], \"audio.wav\", {\n                type: \"audio/wav\",\n            });\n\n            const result = await this.openai!.audio.transcriptions.create({\n                model: \"whisper-1\",\n                language: \"en\",\n                response_format: \"text\",\n                file: file,\n            });\n\n            const trimmedResult = (result as any).trim();\n            elizaLogger.log(`OpenAI speech to text result: \"${trimmedResult}\"`);\n\n            return trimmedResult;\n        } catch (error) {\n            elizaLogger.error(\n                \"Error in OpenAI speech-to-text conversion:\",\n                error\n            );\n            if (error.response) {\n                elizaLogger.error(\"Response data:\", error.response.data);\n                elizaLogger.error(\"Response status:\", error.response.status);\n                elizaLogger.error(\"Response headers:\", error.response.headers);\n            } else if (error.request) {\n                elizaLogger.error(\"No response received:\", error.request);\n            } else {\n                elizaLogger.error(\"Error setting up request:\", error.message);\n            }\n            return null;\n        }\n    }\n\n    /**\n     * Local transcription with nodejs-whisper. We keep it as it was,\n     * just making sure to handle CUDA if available.\n     */\n    public async transcribeLocally(\n        audioBuffer: ArrayBuffer\n    ): Promise<string | null> {\n        try {\n            elizaLogger.log(\"Transcribing audio locally...\");\n\n            await this.saveDebugAudio(audioBuffer, \"local_input_original\");\n\n            const arrayBuffer = new Uint8Array(audioBuffer).buffer;\n            const convertedBuffer = Buffer.from(await this.convertAudio(arrayBuffer)).buffer;\n\n            await this.saveDebugAudio(convertedBuffer, \"local_input_converted\");\n\n            const tempWavFile = path.join(\n                this.CONTENT_CACHE_DIR,\n                `temp_${Date.now()}.wav`\n            );\n\n            // Convert the ArrayBuffer to a Uint8Array which fs.writeFileSync can handle\n            const uint8Array = new Uint8Array(convertedBuffer);\n            fs.writeFileSync(tempWavFile, uint8Array);\n\n            elizaLogger.debug(`Temporary WAV file created: ${tempWavFile}`);\n\n            let output = await nodewhisper(tempWavFile, {\n                modelName: \"base.en\",\n                autoDownloadModelName: \"base.en\",\n                removeWavFileAfterTranscription: false,\n                withCuda: this.isCudaAvailable,\n                whisperOptions: {\n                    outputInText: true,\n                    outputInVtt: false,\n                    outputInSrt: false,\n                    outputInCsv: false,\n                    translateToEnglish: false,\n                    wordTimestamps: false,\n                    timestamps_length: 60,\n                    // splitOnWord: true,\n                },\n            });\n\n            output = output\n                .split(\"\\n\")\n                .map((line) => {\n                    if (line.trim().startsWith(\"[\")) {\n                        const endIndex = line.indexOf(\"]\");\n                        return line.substring(endIndex + 1);\n                    }\n                    return line;\n                })\n                .join(\"\\n\");\n\n            fs.unlinkSync(tempWavFile);\n\n            if (!output || output.length < 5) {\n                elizaLogger.log(\"Output is null or too short, returning null\");\n                return null;\n            }\n            return output;\n        } catch (error) {\n            elizaLogger.error(\n                \"Error in local speech-to-text conversion:\",\n                error\n            );\n            return null;\n        }\n    }\n}\n","import {\n    Action,\n    IAgentRuntime,\n    Memory,\n    State,\n    HandlerCallback,\n    composeContext,\n    generateObject,\n    ActionExample,\n    ModelClass,\n    elizaLogger,\n    ServiceType,\n    IImageDescriptionService,\n} from \"@elizaos/core\";\nimport { getFileLocationTemplate } from \"../templates\";\nimport { FileLocationResultSchema, isFileLocationResult } from \"../types\";\n\nexport const describeImage: Action = {\n    name: \"DESCRIBE_IMAGE\",\n    similes: [\"DESCRIBE_PICTURE\", \"EXPLAIN_PICTURE\", \"EXPLAIN_IMAGE\"],\n    validate: async (_runtime: IAgentRuntime, _message: Memory) => {\n        return true;\n    },\n    description: \"Describe an image\",\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: { [key: string]: unknown },\n        callback?: HandlerCallback\n    ): Promise<boolean> => {\n        // Create context with attachments and URL\n        const getFileLocationContext = composeContext({\n            state,\n            template: getFileLocationTemplate,\n        });\n\n        const fileLocationResultObject = await generateObject({\n            runtime,\n            context: getFileLocationContext,\n            modelClass: ModelClass.SMALL,\n            schema: FileLocationResultSchema,\n            stop: [\"\\n\"],\n        });\n\n        if (!isFileLocationResult(fileLocationResultObject?.object)) {\n            elizaLogger.error(\"Failed to generate file location\");\n            return false;\n        }\n\n        const { fileLocation } = fileLocationResultObject.object;\n\n        const { description } = await runtime\n            .getService<IImageDescriptionService>(ServiceType.IMAGE_DESCRIPTION)\n            .describeImage(fileLocation);\n\n        runtime.messageManager.createMemory({\n            userId: message.agentId,\n            agentId: message.agentId,\n            roomId: message.roomId,\n            content: {\n                text: description,\n            },\n        });\n\n        callback({\n            text: description,\n        });\n\n        return true;\n    },\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Can you describe this image for me?\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"Let me analyze this image for you...\",\n                    action: \"DESCRIBE_IMAGE\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"I see an orange tabby cat sitting on a windowsill. The cat appears to be relaxed and looking out the window at birds flying by. The lighting suggests it's a sunny afternoon.\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"What's in this picture?\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"I'll take a look at that image...\",\n                    action: \"DESCRIBE_IMAGE\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"The image shows a modern kitchen with stainless steel appliances. There's a large island counter in the center with marble countertops. The cabinets are white with sleek handles, and there's pendant lighting hanging above the island.\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Could you tell me what this image depicts?\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"I'll describe this image for you...\",\n                    action: \"DESCRIBE_IMAGE\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"This is a scenic mountain landscape at sunset. The peaks are snow-capped and reflected in a calm lake below. The sky is painted in vibrant oranges and purples, with a few wispy clouds catching the last rays of sunlight.\",\n                },\n            },\n        ],\n    ] as ActionExample[][],\n} as Action;\n","export const getFileLocationTemplate = `\n{{recentMessages}}\n\nextract the file location from the users message or the attachment in the message history that they are referring to.\nyour job is to infer the correct attachment based on the recent messages, the users most recent message, and the attachments in the message\nimage attachments are the result of the users uploads, or images you have created.\nonly respond with the file location, no other text.\ntypically the file location is in the form of a URL or a file path.\n\n\\`\\`\\`json\n{\n    \"fileLocation\": \"file location text goes here\"\n}\n\\`\\`\\`\n`;\n","import { z } from \"zod\";\n\nexport const FileLocationResultSchema = z.object({\n    fileLocation: z.string().min(1),\n});\n\nexport type FileLocationResult = z.infer<typeof FileLocationResultSchema>;\n\nexport function isFileLocationResult(obj: unknown): obj is FileLocationResult {\n    return FileLocationResultSchema.safeParse(obj).success;\n}\n","export * from \"./services/index.js\";\n\nimport { Plugin } from \"@elizaos/core\";\n\nimport { describeImage } from \"./actions/describe-image.js\";\nimport {\n    SpeechService,\n    TranscriptionService,\n} from \"./services/index.js\";\n\nexport const speechTTS: Plugin = {\n        name: \"default\",\n        description: \"Default plugin, with basic actions and evaluators\",\n        services: [\n            new SpeechService(),\n            new TranscriptionService(),\n        ],\n        actions: [describeImage],\n    }\n    \nexport default speechTTS;\n\n"],"mappings":"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","names":["elizaLogger","Service","ServiceType","elizaLogger","ServiceType","z","elizaLogger","ServiceType"]}